<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aeron: aeron::archive::AeronArchive Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aeron
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaeron.html">aeron</a></li><li class="navelem"><b>archive</b></li><li class="navelem"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html">AeronArchive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classaeron_1_1archive_1_1_aeron_archive-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aeron::archive::AeronArchive Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8619ac6434c42697ef021fabddfba997"><td class="memItemLeft" align="right" valign="top"><a id="a8619ac6434c42697ef021fabddfba997"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AeronArchive</b> (const <a class="el" href="classaeron_1_1archive_1_1_context.html">Context</a> &amp;context, const std::int64_t <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2daee32e446673235027a03c9c4d6f40">controlSessionId</a>, <a class="el" href="classaeron_1_1_aeron.html">Aeron</a> &amp;aeron, <a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ae4b08a523f82bbc467d18be5896ac62f">controlResponsePoller</a>, <a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a7045bdb9dc21c1fb361a008d948e875d">archiveProxy</a>, <a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a619202a4859e6df9a1db42fe3d5dbbce">recordingDescriptorPoller</a>)</td></tr>
<tr class="separator:a8619ac6434c42697ef021fabddfba997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daee32e446673235027a03c9c4d6f40"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2daee32e446673235027a03c9c4d6f40">controlSessionId</a> () const</td></tr>
<tr class="separator:a2daee32e446673235027a03c9c4d6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7045bdb9dc21c1fb361a008d948e875d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a7045bdb9dc21c1fb361a008d948e875d">archiveProxy</a> ()</td></tr>
<tr class="separator:a7045bdb9dc21c1fb361a008d948e875d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b08a523f82bbc467d18be5896ac62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ae4b08a523f82bbc467d18be5896ac62f">controlResponsePoller</a> ()</td></tr>
<tr class="separator:ae4b08a523f82bbc467d18be5896ac62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619202a4859e6df9a1db42fe3d5dbbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a619202a4859e6df9a1db42fe3d5dbbce">recordingDescriptorPoller</a> ()</td></tr>
<tr class="separator:a619202a4859e6df9a1db42fe3d5dbbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b36cded8515ecdbd71739da785f0463"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a9b36cded8515ecdbd71739da785f0463">pollForErrorResponse</a> ()</td></tr>
<tr class="separator:a9b36cded8515ecdbd71739da785f0463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f079ec983be0cb878c5ff163a46687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ae7f079ec983be0cb878c5ff163a46687">checkForErrorResponse</a> ()</td></tr>
<tr class="separator:ae7f079ec983be0cb878c5ff163a46687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe08214441aa97e224df5843c8fbbe3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaeron_1_1_publication.html">Publication</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#abfe08214441aa97e224df5843c8fbbe3">addRecordedPublication</a> (const std::string &amp;channel, const std::int32_t streamId)</td></tr>
<tr class="separator:abfe08214441aa97e224df5843c8fbbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38233731c0e1a337144f846e5a29d4b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaeron_1_1_exclusive_publication.html">ExclusivePublication</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ac38233731c0e1a337144f846e5a29d4b">addRecordedExclusivePublication</a> (const std::string &amp;channel, const std::int32_t streamId)</td></tr>
<tr class="separator:ac38233731c0e1a337144f846e5a29d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0fe6abe9bd06ed0118752afcef1bf6"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#afd0fe6abe9bd06ed0118752afcef1bf6">startRecording</a> (const std::string &amp;channel, const std::int32_t streamId, const codecs::SourceLocation::Value sourceLocation)</td></tr>
<tr class="separator:afd0fe6abe9bd06ed0118752afcef1bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71da39326033d28ade9c8806ba1d07bd"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a71da39326033d28ade9c8806ba1d07bd">extendRecording</a> (const std::int64_t recordingId, const std::string &amp;channel, const std::int32_t streamId, const codecs::SourceLocation::Value sourceLocation)</td></tr>
<tr class="separator:a71da39326033d28ade9c8806ba1d07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab72e685ef5bb901ffe6970837187e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a92ab72e685ef5bb901ffe6970837187e">stopRecording</a> (const std::string &amp;channel, const std::int32_t streamId)</td></tr>
<tr class="separator:a92ab72e685ef5bb901ffe6970837187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3830638c084943eb271f19f9227ba897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a3830638c084943eb271f19f9227ba897">stopRecording</a> (const <a class="el" href="classaeron_1_1_publication.html">Publication</a> &amp;publication)</td></tr>
<tr class="separator:a3830638c084943eb271f19f9227ba897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d6560fc35f327ed06754b1ee2f712f"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a75d6560fc35f327ed06754b1ee2f712f">startReplay</a> (const std::int64_t recordingId, const std::int64_t position, const std::int64_t length, const std::string &amp;replayChannel, const std::int32_t replayStreamId)</td></tr>
<tr class="separator:a75d6560fc35f327ed06754b1ee2f712f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50f7d7148fa35094fc6a94881e42f28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ad50f7d7148fa35094fc6a94881e42f28">stopReplay</a> (const std::int64_t replaySessionId)</td></tr>
<tr class="separator:ad50f7d7148fa35094fc6a94881e42f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b0b6299c8956e515aac1e3f708d0cc"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#aa1b0b6299c8956e515aac1e3f708d0cc">replay</a> (const std::int64_t recordingId, const std::int64_t position, const std::int64_t length, const std::string &amp;replayChannel, const std::int32_t replayStreamId)</td></tr>
<tr class="separator:aa1b0b6299c8956e515aac1e3f708d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b61f7de193ad199d00d5e536ff86b4"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a45b61f7de193ad199d00d5e536ff86b4">replay</a> (const std::int64_t recordingId, const std::int64_t position, const std::int64_t length, const std::string &amp;replayChannel, const std::int32_t replayStreamId, const <a class="el" href="namespaceaeron.html#a15cd77f437cd11dd5f0514756b4ed5fe">on_available_image_t</a> &amp;availableImageHandler, const <a class="el" href="namespaceaeron.html#a8f253ecfcf2f0980245de4573daf4bfe">on_unavailable_image_t</a> &amp;unavailableImageHandler)</td></tr>
<tr class="separator:a45b61f7de193ad199d00d5e536ff86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8cd26d9db3c8b0494bc2f940ba131c"><td class="memTemplParams" colspan="2">template&lt;typename RecordingDescriptorConsumer &gt; </td></tr>
<tr class="memitem:a3c8cd26d9db3c8b0494bc2f940ba131c"><td class="memTemplItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a3c8cd26d9db3c8b0494bc2f940ba131c">listRecordings</a> (const std::int64_t fromRecordingId, const std::int32_t recordCount, RecordingDescriptorConsumer &amp;&amp;consumer)</td></tr>
<tr class="separator:a3c8cd26d9db3c8b0494bc2f940ba131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e313ee4fefa4ca4a8a5bb1cf3ed3510"><td class="memTemplParams" colspan="2">template&lt;typename RecordingDescriptorConsumer &gt; </td></tr>
<tr class="memitem:a5e313ee4fefa4ca4a8a5bb1cf3ed3510"><td class="memTemplItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a5e313ee4fefa4ca4a8a5bb1cf3ed3510">listRecordingsForUri</a> (const std::int64_t fromRecordingId, const std::int32_t recordCount, const std::string &amp;channel, const std::int32_t streamId, RecordingDescriptorConsumer &amp;&amp;consumer)</td></tr>
<tr class="separator:a5e313ee4fefa4ca4a8a5bb1cf3ed3510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581d8df05fd245be2183a06de1c89a37"><td class="memTemplParams" colspan="2">template&lt;typename RecordingDescriptorConsumer &gt; </td></tr>
<tr class="memitem:a581d8df05fd245be2183a06de1c89a37"><td class="memTemplItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a581d8df05fd245be2183a06de1c89a37">listRecording</a> (const std::int64_t recordingId, RecordingDescriptorConsumer &amp;&amp;consumer)</td></tr>
<tr class="separator:a581d8df05fd245be2183a06de1c89a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33085b75e4201338f8476fa551b8747e"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a33085b75e4201338f8476fa551b8747e">getRecordingPosition</a> (const std::int64_t recordingId)</td></tr>
<tr class="separator:a33085b75e4201338f8476fa551b8747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a646ab24f40b9917822ff7888cf2d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a0a646ab24f40b9917822ff7888cf2d8c">truncateRecording</a> (const std::int64_t recordingId, const std::int64_t position)</td></tr>
<tr class="separator:a0a646ab24f40b9917822ff7888cf2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a46ba28248c6275a9b064e9702e9f51c2"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html">AeronArchive</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a46ba28248c6275a9b064e9702e9f51c2">connect</a> (const <a class="el" href="classaeron_1_1archive_1_1_context.html">Context</a> &amp;context, const std::int64_t <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2daee32e446673235027a03c9c4d6f40">controlSessionId</a>, <a class="el" href="classaeron_1_1_aeron.html">Aeron</a> &amp;aeron, <a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#ae4b08a523f82bbc467d18be5896ac62f">controlResponsePoller</a>, <a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a7045bdb9dc21c1fb361a008d948e875d">archiveProxy</a>, <a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> &amp;&amp;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a619202a4859e6df9a1db42fe3d5dbbce">recordingDescriptorPoller</a>)</td></tr>
<tr class="separator:a46ba28248c6275a9b064e9702e9f51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af43bacf7e90943f3a2950374bf90a44c"><td class="memItemLeft" align="right" valign="top">static constexpr std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#af43bacf7e90943f3a2950374bf90a44c">NULL_TIMESTAMP</a> = -1</td></tr>
<tr class="separator:af43bacf7e90943f3a2950374bf90a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cab2c540c33b33025f6f835fe2963b1"><td class="memItemLeft" align="right" valign="top">static constexpr std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> = -1</td></tr>
<tr class="separator:a2cab2c540c33b33025f6f835fe2963b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac38233731c0e1a337144f846e5a29d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38233731c0e1a337144f846e5a29d4b">&#9670;&nbsp;</a></span>addRecordedExclusivePublication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classaeron_1_1_exclusive_publication.html">ExclusivePublication</a> &gt; aeron::archive::AeronArchive::addRecordedExclusivePublication </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a <a class="el" href="classaeron_1_1_exclusive_publication.html">ExclusivePublication</a> and set it up to be recorded. </p>
<p>This is a sessionId specific recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>for the publication. </td></tr>
    <tr><td class="paramname">streamId</td><td>for the publication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classaeron_1_1_exclusive_publication.html">ExclusivePublication</a> ready for use. </dd></dl>

</div>
</div>
<a id="abfe08214441aa97e224df5843c8fbbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe08214441aa97e224df5843c8fbbe3">&#9670;&nbsp;</a></span>addRecordedPublication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classaeron_1_1_publication.html">Publication</a> &gt; aeron::archive::AeronArchive::addRecordedPublication </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a <a class="el" href="classaeron_1_1_publication.html">Publication</a> and set it up to be recorded. If this is not the first, i.e. <a class="el" href="classaeron_1_1_publication.html#a06575747d03fee04441dc9af9ae84470">Publication#isOriginal()</a> is true, then an <a class="el" href="">IllegalStateException</a> will be thrown and the recording not initiated. </p>
<p>This is a sessionId specific recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>for the publication. </td></tr>
    <tr><td class="paramname">streamId</td><td>for the publication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classaeron_1_1_publication.html">Publication</a> ready for use. </dd></dl>

</div>
</div>
<a id="a7045bdb9dc21c1fb361a008d948e875d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7045bdb9dc21c1fb361a008d948e875d">&#9670;&nbsp;</a></span>archiveProxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a>&amp; aeron::archive::AeronArchive::archiveProxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> for send asynchronous messages to the connected archive.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> for send asynchronous messages to the connected archive. </dd></dl>

</div>
</div>
<a id="ae7f079ec983be0cb878c5ff163a46687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f079ec983be0cb878c5ff163a46687">&#9670;&nbsp;</a></span>checkForErrorResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aeron::archive::AeronArchive::checkForErrorResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if an error has been returned for the control session and throw a <a class="el" href="classaeron_1_1archive_1_1_archive_exception.html">ArchiveException</a> if necessary. To check for an error response without raising an exception then try <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a9b36cded8515ecdbd71739da785f0463">pollForErrorResponse()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a9b36cded8515ecdbd71739da785f0463">pollForErrorResponse()</a> </dd></dl>

</div>
</div>
<a id="a46ba28248c6275a9b064e9702e9f51c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ba28248c6275a9b064e9702e9f51c2">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html">AeronArchive</a>&gt; aeron::archive::AeronArchive::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaeron_1_1archive_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>controlSessionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaeron_1_1_aeron.html">Aeron</a> &amp;&#160;</td>
          <td class="paramname"><em>aeron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>controlResponsePoller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaeron_1_1archive_1_1_archive_proxy.html">ArchiveProxy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>archiveProxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>recordingDescriptorPoller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect to an <a class="el" href="classaeron_1_1_aeron.html">Aeron</a> archive by providing a <a class="el" href="classaeron_1_1archive_1_1_context.html">Context</a>. This will create a control session. </p>
<p>Before connecting <a class="el" href="">Context#conclude()</a> will be called. If an exception occurs then <a class="el" href="">Context#close()</a> will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>for connection configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classaeron_1_1_aeron.html">Aeron</a> Archive client. </dd></dl>

</div>
</div>
<a id="ae4b08a523f82bbc467d18be5896ac62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b08a523f82bbc467d18be5896ac62f">&#9670;&nbsp;</a></span>controlResponsePoller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a>&amp; aeron::archive::AeronArchive::controlResponsePoller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> for polling additional events on the control channel.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classaeron_1_1archive_1_1_control_response_poller.html">ControlResponsePoller</a> for polling additional events on the control channel. </dd></dl>

</div>
</div>
<a id="a2daee32e446673235027a03c9c4d6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daee32e446673235027a03c9c4d6f40">&#9670;&nbsp;</a></span>controlSessionId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::controlSessionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin an attempt at creating a connection which can be completed by calling <a class="el" href="">AsyncConnect#poll()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="">AsyncConnect</a> that cannot be polled for completion. Begin an attempt at creating a connection which can be completed by calling <a class="el" href="">AsyncConnect#poll()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>for the archive connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="">AsyncConnect</a> that cannot be polled for completion. The control session id allocated for this connection to the archive.</dd>
<dd>
control session id allocated for this connection to the archive. </dd></dl>

</div>
</div>
<a id="a71da39326033d28ade9c8806ba1d07bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71da39326033d28ade9c8806ba1d07bd">&#9670;&nbsp;</a></span>extendRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::extendRecording </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const codecs::SourceLocation::Value&#160;</td>
          <td class="paramname"><em>sourceLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend an existing, non-active recording of a channel and stream pairing. </p>
<p>Channel must be session specific and include the existing recording sessionId.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>of the existing recording. </td></tr>
    <tr><td class="paramname">channel</td><td>to be recorded. </td></tr>
    <tr><td class="paramname">streamId</td><td>to be recorded. </td></tr>
    <tr><td class="paramname">sourceLocation</td><td>of the publication to be recorded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correlationId used to identify the request. </dd></dl>

</div>
</div>
<a id="a33085b75e4201338f8476fa551b8747e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33085b75e4201338f8476fa551b8747e">&#9670;&nbsp;</a></span>getRecordingPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::getRecordingPosition </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the position recorded for an active recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>of the active recording for which the position is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the recorded position for the active recording or <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> if recording not active. </dd></dl>

</div>
</div>
<a id="a581d8df05fd245be2183a06de1c89a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581d8df05fd245be2183a06de1c89a37">&#9670;&nbsp;</a></span>listRecording()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordingDescriptorConsumer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t aeron::archive::AeronArchive::listRecording </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordingDescriptorConsumer &amp;&amp;&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List all recording descriptors from a recording id with a limit of record count. </p>
<p>If the recording id is greater than the largest known id then nothing is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>at which to begin the listing. </td></tr>
    <tr><td class="paramname">consumer</td><td>to which the descriptors are dispatched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of descriptors found and consumed. </dd></dl>

</div>
</div>
<a id="a3c8cd26d9db3c8b0494bc2f940ba131c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8cd26d9db3c8b0494bc2f940ba131c">&#9670;&nbsp;</a></span>listRecordings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordingDescriptorConsumer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t aeron::archive::AeronArchive::listRecordings </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>fromRecordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>recordCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordingDescriptorConsumer &amp;&amp;&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List all recording descriptors from a recording id with a limit of record count. </p>
<p>If the recording id is greater than the largest known id then nothing is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromRecordingId</td><td>at which to begin the listing. </td></tr>
    <tr><td class="paramname">recordCount</td><td>to limit for each query. </td></tr>
    <tr><td class="paramname">consumer</td><td>to which the descriptors are dispatched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of descriptors found and consumed. </dd></dl>

</div>
</div>
<a id="a5e313ee4fefa4ca4a8a5bb1cf3ed3510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e313ee4fefa4ca4a8a5bb1cf3ed3510">&#9670;&nbsp;</a></span>listRecordingsForUri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordingDescriptorConsumer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t aeron::archive::AeronArchive::listRecordingsForUri </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>fromRecordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>recordCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordingDescriptorConsumer &amp;&amp;&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List recording descriptors from a recording id with a limit of record count for a given channel and stream id. </p>
<p>If the recording id is greater than the largest known id then nothing is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromRecordingId</td><td>at which to begin the listing. </td></tr>
    <tr><td class="paramname">recordCount</td><td>to limit for each query. </td></tr>
    <tr><td class="paramname">channel</td><td>for a contains match on the stripped channel stored with the archive descriptor </td></tr>
    <tr><td class="paramname">streamId</td><td>to match. </td></tr>
    <tr><td class="paramname">consumer</td><td>to which the descriptors are dispatched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of descriptors found and consumed. </dd></dl>

</div>
</div>
<a id="a9b36cded8515ecdbd71739da785f0463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b36cded8515ecdbd71739da785f0463">&#9670;&nbsp;</a></span>pollForErrorResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string aeron::archive::AeronArchive::pollForErrorResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Poll the response stream once for an error. If another message is present then it will be skipped over so only call when not expecting another response.</p>
<dl class="section return"><dt>Returns</dt><dd>the error string otherwise null if no error is found. </dd></dl>

</div>
</div>
<a id="a619202a4859e6df9a1db42fe3d5dbbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619202a4859e6df9a1db42fe3d5dbbce">&#9670;&nbsp;</a></span>recordingDescriptorPoller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a>&amp; aeron::archive::AeronArchive::recordingDescriptorPoller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> for polling recording descriptors on the control channel.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classaeron_1_1archive_1_1_recording_descriptor_poller.html">RecordingDescriptorPoller</a> for polling recording descriptors on the control channel. </dd></dl>

</div>
</div>
<a id="aa1b0b6299c8956e515aac1e3f708d0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b0b6299c8956e515aac1e3f708d0cc">&#9670;&nbsp;</a></span>replay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::replay </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replayChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>replayStreamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replay a length in bytes of a recording from a position and for convenience create a <a class="el" href="classaeron_1_1_subscription.html">Subscription</a> to receive the replay. If the position is <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> then the stream will be replayed from the start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>to be replayed. </td></tr>
    <tr><td class="paramname">position</td><td>from which the replay should begin or <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> if from the start. </td></tr>
    <tr><td class="paramname">length</td><td>of the stream to be replayed or <a class="el" href="">std::int64_t#MAX_VALUE</a> to follow a live recording. </td></tr>
    <tr><td class="paramname">replayChannel</td><td>to which the replay should be sent. </td></tr>
    <tr><td class="paramname">replayStreamId</td><td>to which the replay should be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>registration id for the <a class="el" href="classaeron_1_1_subscription.html">Subscription</a> for consuming the replay. </dd></dl>

</div>
</div>
<a id="a45b61f7de193ad199d00d5e536ff86b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b61f7de193ad199d00d5e536ff86b4">&#9670;&nbsp;</a></span>replay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::replay </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replayChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>replayStreamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaeron.html#a15cd77f437cd11dd5f0514756b4ed5fe">on_available_image_t</a> &amp;&#160;</td>
          <td class="paramname"><em>availableImageHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaeron.html#a8f253ecfcf2f0980245de4573daf4bfe">on_unavailable_image_t</a> &amp;&#160;</td>
          <td class="paramname"><em>unavailableImageHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replay a length in bytes of a recording from a position and for convenience create a <a class="el" href="classaeron_1_1_subscription.html">Subscription</a> to receive the replay. If the position is <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> then the stream will be replayed from the start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>to be replayed. </td></tr>
    <tr><td class="paramname">position</td><td>from which the replay should begin or <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> if from the start. </td></tr>
    <tr><td class="paramname">length</td><td>of the stream to be replayed or <a class="el" href="">std::int64_t#MAX_VALUE</a> to follow a live recording. </td></tr>
    <tr><td class="paramname">replayChannel</td><td>to which the replay should be sent. </td></tr>
    <tr><td class="paramname">replayStreamId</td><td>to which the replay should be sent. </td></tr>
    <tr><td class="paramname">availableImageHandler</td><td>to be called when the replay image becomes available. </td></tr>
    <tr><td class="paramname">unavailableImageHandler</td><td>to be called when the replay image goes unavailable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>registration id for the <a class="el" href="classaeron_1_1_subscription.html">Subscription</a> for consuming the replay. </dd></dl>

</div>
</div>
<a id="afd0fe6abe9bd06ed0118752afcef1bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0fe6abe9bd06ed0118752afcef1bf6">&#9670;&nbsp;</a></span>startRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::startRecording </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const codecs::SourceLocation::Value&#160;</td>
          <td class="paramname"><em>sourceLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start recording a channel and stream pairing. </p>
<p>Channels that include sessionId parameters are considered different than channels without sessionIds. If a publication matches both a sessionId specific channel recording and a non-sessionId specific recording, it will be recorded twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>to be recorded. </td></tr>
    <tr><td class="paramname">streamId</td><td>to be recorded. </td></tr>
    <tr><td class="paramname">sourceLocation</td><td>of the publication to be recorded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correlationId used to identify the request. </dd></dl>

</div>
</div>
<a id="a75d6560fc35f327ed06754b1ee2f712f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d6560fc35f327ed06754b1ee2f712f">&#9670;&nbsp;</a></span>startReplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::archive::AeronArchive::startReplay </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replayChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>replayStreamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a replay for a length in bytes of a recording from a position. If the position is <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> then the stream will be replayed from the start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>to be replayed. </td></tr>
    <tr><td class="paramname">position</td><td>from which the replay should begin or <a class="el" href="classaeron_1_1archive_1_1_aeron_archive.html#a2cab2c540c33b33025f6f835fe2963b1">NULL_POSITION</a> if from the start. </td></tr>
    <tr><td class="paramname">length</td><td>of the stream to be replayed. Use <a class="el" href="">std::int64_t#MAX_VALUE</a> to follow a live recording. </td></tr>
    <tr><td class="paramname">replayChannel</td><td>to which the replay should be sent. </td></tr>
    <tr><td class="paramname">replayStreamId</td><td>to which the replay should be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the replay session which will be the same as the <a class="el" href="classaeron_1_1_image.html#afc974640a00037f5ed2e86916897e9c9">Image#sessionId()</a> of the received replay for correlation with the matching channel and stream id. </dd></dl>

</div>
</div>
<a id="a92ab72e685ef5bb901ffe6970837187e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ab72e685ef5bb901ffe6970837187e">&#9670;&nbsp;</a></span>stopRecording() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aeron::archive::AeronArchive::stopRecording </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>streamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop recording for a channel and stream pairing. </p>
<p>Channels that include sessionId parameters are considered different than channels without sessionIds. Stopping a recording on a channel without a sessionId parameter will not stop the recording of any sessionId specific recordings that use the same channel and streamId.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>to stop recording for. </td></tr>
    <tr><td class="paramname">streamId</td><td>to stop recording for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3830638c084943eb271f19f9227ba897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3830638c084943eb271f19f9227ba897">&#9670;&nbsp;</a></span>stopRecording() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aeron::archive::AeronArchive::stopRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaeron_1_1_publication.html">Publication</a> &amp;&#160;</td>
          <td class="paramname"><em>publication</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop recording a sessionId specific recording that pertains to the given <a class="el" href="classaeron_1_1_publication.html">Publication</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publication</td><td>to stop recording for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad50f7d7148fa35094fc6a94881e42f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50f7d7148fa35094fc6a94881e42f28">&#9670;&nbsp;</a></span>stopReplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aeron::archive::AeronArchive::stopReplay </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>replaySessionId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a replay session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replaySessionId</td><td>to stop replay for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a646ab24f40b9917822ff7888cf2d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a646ab24f40b9917822ff7888cf2d8c">&#9670;&nbsp;</a></span>truncateRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aeron::archive::AeronArchive::truncateRecording </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>recordingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate a stopped recording to a given position that is less than the stopped position. The provided position must be on a fragment boundary. Truncating a recording to the start position effectively deletes the recording.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordingId</td><td>of the stopped recording to be truncated. </td></tr>
    <tr><td class="paramname">position</td><td>to which the recording will be truncated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2cab2c540c33b33025f6f835fe2963b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cab2c540c33b33025f6f835fe2963b1">&#9670;&nbsp;</a></span>NULL_POSITION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int64_t aeron::archive::AeronArchive::NULL_POSITION = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Represents a position that has not been set. Can be used when the position is not known. </p>

</div>
</div>
<a id="af43bacf7e90943f3a2950374bf90a44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43bacf7e90943f3a2950374bf90a44c">&#9670;&nbsp;</a></span>NULL_TIMESTAMP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int64_t aeron::archive::AeronArchive::NULL_TIMESTAMP = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Represents a timestamp that has not been set. Can be used when the time is not known. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/deniz/work/thirdparty/aeron/aeron-archive/src/main/cpp/client/<a class="el" href="_aeron_archive_8h_source.html">AeronArchive.h</a></li>
<li>/home/deniz/work/thirdparty/aeron/aeron-archive/src/main/cpp/client/AeronArchive.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 27 2018 13:34:44 for Aeron by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
