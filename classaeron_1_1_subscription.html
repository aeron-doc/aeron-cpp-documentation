<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aeron: aeron::Subscription Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aeron
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaeron.html">aeron</a></li><li class="navelem"><a class="el" href="classaeron_1_1_subscription.html">Subscription</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classaeron_1_1_subscription-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aeron::Subscription Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_subscription_8h_source.html">Subscription.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72f07b2b97ef12d30cc389ea43cd46ba"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a72f07b2b97ef12d30cc389ea43cd46ba">channel</a> () const</td></tr>
<tr class="separator:a72f07b2b97ef12d30cc389ea43cd46ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d7eda7e8b7fb9b13b555116c2b9bbd"><td class="memItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#ae0d7eda7e8b7fb9b13b555116c2b9bbd">streamId</a> () const</td></tr>
<tr class="separator:ae0d7eda7e8b7fb9b13b555116c2b9bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fdc56c1e07d54fca04cd769380157e"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a13fdc56c1e07d54fca04cd769380157e">registrationId</a> () const</td></tr>
<tr class="separator:a13fdc56c1e07d54fca04cd769380157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad871a79be8dfaba225c010264477e5cb"><td class="memItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#ad871a79be8dfaba225c010264477e5cb">channelStatusId</a> () const</td></tr>
<tr class="separator:ad871a79be8dfaba225c010264477e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8afbd283ea2e87fdb0d9bff422b555"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4d8afbd283ea2e87fdb0d9bff422b555"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a4d8afbd283ea2e87fdb0d9bff422b555">pollEndOfStreams</a> (F &amp;&amp;endOfStreamHandler)</td></tr>
<tr class="separator:a4d8afbd283ea2e87fdb0d9bff422b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc809b9965ce0ea825225dc63bede8b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:accc809b9965ce0ea825225dc63bede8b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#accc809b9965ce0ea825225dc63bede8b">poll</a> (F &amp;&amp;fragmentHandler, int fragmentLimit)</td></tr>
<tr class="separator:accc809b9965ce0ea825225dc63bede8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fb6976ca71f96f6940a238c5277546"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab3fb6976ca71f96f6940a238c5277546"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#ab3fb6976ca71f96f6940a238c5277546">controlledPoll</a> (F &amp;&amp;fragmentHandler, int fragmentLimit)</td></tr>
<tr class="separator:ab3fb6976ca71f96f6940a238c5277546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cbc67fcbb195aabfddbd88f9b12333"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a04cbc67fcbb195aabfddbd88f9b12333"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a04cbc67fcbb195aabfddbd88f9b12333">blockPoll</a> (F &amp;&amp;blockHandler, int blockLengthLimit)</td></tr>
<tr class="separator:a04cbc67fcbb195aabfddbd88f9b12333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d4476acb1c8be165e6b139885baf9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a17d4476acb1c8be165e6b139885baf9c">isConnected</a> () const</td></tr>
<tr class="separator:a17d4476acb1c8be165e6b139885baf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b809ed16c331522c2e73151d8e205fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a8b809ed16c331522c2e73151d8e205fb">imageCount</a> () const</td></tr>
<tr class="separator:a8b809ed16c331522c2e73151d8e205fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4386db1842728038a8ede200d0483e86"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaeron_1_1_image.html">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a4386db1842728038a8ede200d0483e86">imageBySessionId</a> (std::int32_t sessionId) const</td></tr>
<tr class="separator:a4386db1842728038a8ede200d0483e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b140e1cc3fd37b7a013b7ea7c83f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaeron_1_1_image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a80b140e1cc3fd37b7a013b7ea7c83f5e">imageAtIndex</a> (size_t index) const</td></tr>
<tr class="separator:a80b140e1cc3fd37b7a013b7ea7c83f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692ec7e886c158e5f15a252dadaeee94"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; std::vector&lt; <a class="el" href="classaeron_1_1_image.html">Image</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a692ec7e886c158e5f15a252dadaeee94">images</a> ()</td></tr>
<tr class="separator:a692ec7e886c158e5f15a252dadaeee94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dfa3a843386c3d109f82e3f2a9f452"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a41dfa3a843386c3d109f82e3f2a9f452"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#a41dfa3a843386c3d109f82e3f2a9f452">forEachImage</a> (F &amp;&amp;func)</td></tr>
<tr class="separator:a41dfa3a843386c3d109f82e3f2a9f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4db4cd16dafda217461f1bf5ac87b4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#ab4db4cd16dafda217461f1bf5ac87b4d">isClosed</a> () const</td></tr>
<tr class="separator:ab4db4cd16dafda217461f1bf5ac87b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bfd222f8305a5075d5c00eb67f37a2"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaeron_1_1_subscription.html#ac2bfd222f8305a5075d5c00eb67f37a2">channelStatus</a> ()</td></tr>
<tr class="separator:ac2bfd222f8305a5075d5c00eb67f37a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classaeron_1_1_aeron.html">Aeron</a> Subscriber API for receiving messages from publishers on a given channel and streamId pair. Subscribers are created via an <a class="el" href="classaeron_1_1_aeron.html">Aeron</a> object, and received messages are delivered to the <a class="el" href="">fragment_handler_t</a>. </p>
<p>By default fragmented messages are not reassembled before delivery. If an application must receive whole messages, whether or not they were fragmented, then the Subscriber should be created with a <a class="el" href="classaeron_1_1_fragment_assembler.html">FragmentAssembler</a> or a custom implementation. </p>
<p>It is an applications responsibility to <a class="el" href="classaeron_1_1_subscription.html#accc809b9965ce0ea825225dc63bede8b">poll</a> the Subscriber for new messages. </p>
<p>Subscriptions are not threadsafe and should not be shared between subscribers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classaeron_1_1_fragment_assembler.html">FragmentAssembler</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a04cbc67fcbb195aabfddbd88f9b12333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cbc67fcbb195aabfddbd88f9b12333">&#9670;&nbsp;</a></span>blockPoll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long aeron::Subscription::blockPoll </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>blockHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockLengthLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Poll the <a class="el" href="classaeron_1_1_image.html">Image</a> s under the subscription for available message fragments in blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockHandler</td><td>to receive a block of fragments from each <a class="el" href="classaeron_1_1_image.html">Image</a>. </td></tr>
    <tr><td class="paramname">blockLengthLimit</td><td>for each individual block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed. </dd></dl>

</div>
</div>
<a id="a72f07b2b97ef12d30cc389ea43cd46ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f07b2b97ef12d30cc389ea43cd46ba">&#9670;&nbsp;</a></span>channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; aeron::Subscription::channel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Media address for delivery to the channel.</p>
<dl class="section return"><dt>Returns</dt><dd>Media address for delivery to the channel. </dd></dl>

</div>
</div>
<a id="ac2bfd222f8305a5075d5c00eb67f37a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bfd222f8305a5075d5c00eb67f37a2">&#9670;&nbsp;</a></span>channelStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::Subscription::channelStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the status for the channel of this <a class="el" href="classaeron_1_1_publication.html">Publication</a></p>
<dl class="section return"><dt>Returns</dt><dd>status code for this channel </dd></dl>

</div>
</div>
<a id="ad871a79be8dfaba225c010264477e5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad871a79be8dfaba225c010264477e5cb">&#9670;&nbsp;</a></span>channelStatusId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t aeron::Subscription::channelStatusId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the counter id used to represent the channel status.</p>
<dl class="section return"><dt>Returns</dt><dd>the counter id used to represent the channel status. </dd></dl>

</div>
</div>
<a id="ab3fb6976ca71f96f6940a238c5277546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fb6976ca71f96f6940a238c5277546">&#9670;&nbsp;</a></span>controlledPoll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aeron::Subscription::controlledPoll </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>fragmentHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragmentLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Poll in a controlled manner the <a class="el" href="classaeron_1_1_image.html">Image</a> s under the subscription for available message fragments. Control is applied to fragments in the stream. If more fragments can be read on another stream they will even if BREAK or ABORT is returned from the fragment handler. </p>
<p>Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come as a series of fragments ordered within a session. </p>
<p>To assemble messages that span multiple fragments then use controlled_poll_fragment_handler_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fragmentHandler</td><td>callback for handling each message fragment as it is read. </td></tr>
    <tr><td class="paramname">fragmentLimit</td><td>number of message fragments to limit for the poll operation across multiple <a class="el" href="classaeron_1_1_image.html">Image</a> s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fragments received </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceaeron.html#a758fa7767a8fb4a63d8990c4ca9de8ae">controlled_poll_fragment_handler_t</a> </dd></dl>

</div>
</div>
<a id="a41dfa3a843386c3d109f82e3f2a9f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dfa3a843386c3d109f82e3f2a9f452">&#9670;&nbsp;</a></span>forEachImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aeron::Subscription::forEachImage </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterate over <a class="el" href="classaeron_1_1_image.html">Image</a> list and call passed in function.</p>
<dl class="section return"><dt>Returns</dt><dd>length of <a class="el" href="classaeron_1_1_image.html">Image</a> list </dd></dl>

</div>
</div>
<a id="a80b140e1cc3fd37b7a013b7ea7c83f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b140e1cc3fd37b7a013b7ea7c83f5e">&#9670;&nbsp;</a></span>imageAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaeron_1_1_image.html">Image</a>&amp; aeron::Subscription::imageAtIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the image at the given index from the images array.</p>
<p>This is only valid until the image list changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image at given index or exception if out of range. </dd></dl>

</div>
</div>
<a id="a4386db1842728038a8ede200d0483e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4386db1842728038a8ede200d0483e86">&#9670;&nbsp;</a></span>imageBySessionId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classaeron_1_1_image.html">Image</a>&gt; aeron::Subscription::imageBySessionId </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>sessionId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classaeron_1_1_image.html">Image</a> associated with the given sessionId.</p>
<p>This method generates a new copy of the <a class="el" href="classaeron_1_1_image.html">Image</a> overlaying the logbuffer. It is up to the application to not use the <a class="el" href="classaeron_1_1_image.html">Image</a> if it becomes unavailable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sessionId</td><td>associated with the <a class="el" href="classaeron_1_1_image.html">Image</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classaeron_1_1_image.html">Image</a> associated with the given sessionId or nullptr if no <a class="el" href="classaeron_1_1_image.html">Image</a> exist. </dd></dl>

</div>
</div>
<a id="a8b809ed16c331522c2e73151d8e205fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b809ed16c331522c2e73151d8e205fb">&#9670;&nbsp;</a></span>imageCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aeron::Subscription::imageCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count of images connected to this subscription.</p>
<dl class="section return"><dt>Returns</dt><dd>count of images connected to this subscription. </dd></dl>

</div>
</div>
<a id="a692ec7e886c158e5f15a252dadaeee94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692ec7e886c158e5f15a252dadaeee94">&#9670;&nbsp;</a></span>images()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;std::vector&lt;<a class="el" href="classaeron_1_1_image.html">Image</a>&gt; &gt; aeron::Subscription::images </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a std::vector of active <a class="el" href="classaeron_1_1_image.html">Image</a>s that match this subscription.</p>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of active <a class="el" href="classaeron_1_1_image.html">Image</a>s that match this subscription. </dd></dl>

</div>
</div>
<a id="ab4db4cd16dafda217461f1bf5ac87b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4db4cd16dafda217461f1bf5ac87b4d">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aeron::Subscription::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Has this object been closed and should no longer be used?</p>
<dl class="section return"><dt>Returns</dt><dd>true if it has been closed otherwise false. </dd></dl>

</div>
</div>
<a id="a17d4476acb1c8be165e6b139885baf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d4476acb1c8be165e6b139885baf9c">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aeron::Subscription::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the subscription connected by having at least one image available.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the subscription has more than one image available. </dd></dl>

</div>
</div>
<a id="accc809b9965ce0ea825225dc63bede8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc809b9965ce0ea825225dc63bede8b">&#9670;&nbsp;</a></span>poll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aeron::Subscription::poll </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>fragmentHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragmentLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Poll the <a class="el" href="classaeron_1_1_image.html">Image</a>s under the subscription for available message fragments. </p>
<p>Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come as a series of fragments ordered withing a session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fragmentHandler</td><td>callback for handling each message fragment as it is read. </td></tr>
    <tr><td class="paramname">fragmentLimit</td><td>number of message fragments to limit for the poll across multiple <a class="el" href="classaeron_1_1_image.html">Image</a> s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fragments received</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fragment_handler_t </dd></dl>

</div>
</div>
<a id="a4d8afbd283ea2e87fdb0d9bff422b555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8afbd283ea2e87fdb0d9bff422b555">&#9670;&nbsp;</a></span>pollEndOfStreams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aeron::Subscription::pollEndOfStreams </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>endOfStreamHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Poll the <a class="el" href="classaeron_1_1_image.html">Image</a> s under the subscription for having reached End of Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endOfStreamHandler</td><td>callback for handling end of stream indication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of <a class="el" href="classaeron_1_1_image.html">Image</a> s that have reached End of Stream. </dd></dl>

</div>
</div>
<a id="a13fdc56c1e07d54fca04cd769380157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fdc56c1e07d54fca04cd769380157e">&#9670;&nbsp;</a></span>registrationId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t aeron::Subscription::registrationId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registration Id returned by <a class="el" href="classaeron_1_1_aeron.html#a7e4a109310e924d2c76ef67985640c01">Aeron::addSubscription</a> when this <a class="el" href="classaeron_1_1_subscription.html">Subscription</a> was added.</p>
<dl class="section return"><dt>Returns</dt><dd>the registrationId of the subscription. </dd></dl>

</div>
</div>
<a id="ae0d7eda7e8b7fb9b13b555116c2b9bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d7eda7e8b7fb9b13b555116c2b9bbd">&#9670;&nbsp;</a></span>streamId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t aeron::Subscription::streamId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stream identity for scoping within the channel media address.</p>
<dl class="section return"><dt>Returns</dt><dd>Stream identity for scoping within the channel media address. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/deniz/work/thirdparty/aeron/aeron-client/src/main/cpp/<a class="el" href="_subscription_8h_source.html">Subscription.h</a></li>
<li>/home/deniz/work/thirdparty/aeron/aeron-client/src/main/cpp/Subscription.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 16 2018 19:20:32 for Aeron by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
